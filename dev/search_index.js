var documenterSearchIndex = {"docs":
[{"location":"gallery/","page":"Gallery","title":"Gallery","text":"using NeutralLandscapes\nusing Plots\n\nfunction demolandscape(alg::T) where {T <: NeutralLandscapeMaker}\n    heatmap(rand(alg, (200, 200)), frame=:none, aspectratio=1, c=:davos)\nend","category":"page"},{"location":"gallery/#No-gradient","page":"Gallery","title":"No gradient","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(NoGradient())","category":"page"},{"location":"gallery/#Planar-gradient","page":"Gallery","title":"Planar gradient","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(PlanarGradient(35))","category":"page"},{"location":"gallery/#Edge-gradient","page":"Gallery","title":"Edge gradient","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(EdgeGradient(186))","category":"page"},{"location":"gallery/#Wave-surface","page":"Gallery","title":"Wave surface","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(WaveSurface(35, 3))","category":"page"},{"location":"gallery/#Rectangular-cluster","page":"Gallery","title":"Rectangular cluster","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(RectangularCluster())","category":"page"},{"location":"gallery/#Distance-gradient","page":"Gallery","title":"Distance gradient","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"sources = unique(rand(1:40000, 50))\ndemolandscape(DistanceGradient(sources))","category":"page"},{"location":"gallery/#Nearest-neighbor-element","page":"Gallery","title":"Nearest-neighbor element","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"heatmap(rand(NearestNeighborElement(20, 1), (45, 45)))","category":"page"},{"location":"gallery/#Perlin-Noise","page":"Gallery","title":"Perlin Noise","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(PerlinNoise())","category":"page"},{"location":"gallery/#Classify-landscape","page":"Gallery","title":"Classify landscape","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"sources = unique(rand(1:40000, 50))\nheatmap(NeutralLandscapes.classify!(rand(DistanceGradient(sources), (200, 200)), [0.5, 1, 1, 0.5]))","category":"page"},{"location":"gallery/#Diamond-Square","page":"Gallery","title":"Diamond Square","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(DiamondSquare())","category":"page"},{"location":"gallery/#Midpoint-Displacement","page":"Gallery","title":"Midpoint Displacement","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"demolandscape(MidpointDisplacement())","category":"page"},{"location":"#NeutralLandscapes.jl","page":"Index","title":"NeutralLandscapes.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"A pure Julia port of https://github.com/tretherington/nlmpy","category":"page"},{"location":"#Landscape-models","page":"Index","title":"Landscape models","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"NeutralLandscapeMaker\nNoGradient\nPlanarGradient\nEdgeGradient\nWaveSurface\nDistanceGradient\nRectangularCluster\nNearestNeighborElement\nPerlinNoise","category":"page"},{"location":"#NeutralLandscapes.NeutralLandscapeMaker","page":"Index","title":"NeutralLandscapes.NeutralLandscapeMaker","text":"All algorithms are descended from the NeutralLandscapeMaker type. A new algorithm must minimally implement and _landscape! method for this type.\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.NoGradient","page":"Index","title":"NeutralLandscapes.NoGradient","text":"NoGradient\n\nThis type is used to generate a random landscape with no gradients\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.PlanarGradient","page":"Index","title":"NeutralLandscapes.PlanarGradient","text":"PlanarGradient\n\nThis type is used to generate a planar gradient landscape, where values change as a bilinear function of the x and y coordinates. The direction is expressed as a floating point value, which will be in [0,360]. The inner constructor takes the mod of the value passed and 360, so that a value that is out of the correct interval will be corrected.\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.EdgeGradient","page":"Index","title":"NeutralLandscapes.EdgeGradient","text":"EdgeGradient\n\nThis type is used to generate an edge gradient landscape, where values change as a bilinear function of the x and y coordinates. The direction is expressed as a floating point value, which will be in [0,360]. The inner constructor takes the mod of the value passed and 360, so that a value that is out of the correct interval will be corrected.\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.WaveSurface","page":"Index","title":"NeutralLandscapes.WaveSurface","text":"WaveSurface\n\nCreates a sinusoidal landscape with a direction and a number of periods. If neither are specified, there will be a single period of random direction.\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.DistanceGradient","page":"Index","title":"NeutralLandscapes.DistanceGradient","text":"DistanceGradient\n\nThe sources field is the linear indices of the matrix, from which the distance must be calculated.\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.RectangularCluster","page":"Index","title":"NeutralLandscapes.RectangularCluster","text":"RectangularCluster\n\nFills the landscape with rectangles containing a random value. The size of each rectangle/patch is between minimum and maximum (the two can be equal for a fixed size rectangle).\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.NearestNeighborElement","page":"Index","title":"NeutralLandscapes.NearestNeighborElement","text":"NearestNeighborElement\n\nAssigns a value to each patch using a k-NN algorithmm with n initial clusters and k neighbors. The default is to use three cluster and a single neighbor.\n\n\n\n\n\n","category":"type"},{"location":"#NeutralLandscapes.PerlinNoise","page":"Index","title":"NeutralLandscapes.PerlinNoise","text":"PerlinNoise <: NeutralLandscapeMaker\n\nPerlinNoise(; kw...)\n\nCreate a Perlin noise neutral landscape model with values ranging 0-1.\n\nKeywords\n\nperiods::Tuple{Int,Int}=(1,1): the number of periods of Perlin noise across row and    column dimensions for the first octave.\noctaves::Int=1: the number of octaves that will form the Perlin noise.\nlacunarity::Int=2 : the rate at which the frequency of periods increases for each    octive.\npersistance::Real=0.5 : the rate at which the amplitude of periods decreases for each    octive.\nvalley::Symbol=:u: the kind of valley bottom that will be mimicked::uproduces    u-shaped valleys,:vproduces v-shaped valleys, and:-` produces flat bottomed    valleys.\n\nNote: This is a memory-intensive algorithm with some settings. Be careful using larger  prime numbers for period when also using a large array size, high lacuarity and/or many  octaves. Memory use scales with the lowest common multiple of periods.\n\n\n\n\n\n","category":"type"},{"location":"#Landscape-generating-function","page":"Index","title":"Landscape generating function","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"rand!\nrand\n_landscape!","category":"page"},{"location":"#Random.rand!","page":"Index","title":"Random.rand!","text":"rand!(mat, alg) where {IT <: Integer}\n\nFill the matrix mat with a landscape created following the model defined by alg. The mask argument accepts a matrix of boolean values, and is passed to mask! if it is not nothing. \n\n\n\n\n\n","category":"function"},{"location":"#Base.rand","page":"Index","title":"Base.rand","text":"rand(alg, dims::Tuple{Vararg{Int64,2}}; mask=nothing) where {T <: Integer}\n\nCreates a landscape of size dims (a tuple of two integers) following the model defined by alg. The mask argument accepts a matrix of boolean values, and is passed to mask! if it is not nothing. \n\n\n\n\n\n","category":"function"},{"location":"#Other-functions","page":"Index","title":"Other functions","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"mask!","category":"page"}]
}
